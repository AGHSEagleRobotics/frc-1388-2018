// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1388.commands;

import edu.wpi.first.wpilibj.command.CommandGroup;
import edu.wpi.first.wpilibj.command.WaitCommand;

import org.usfirst.frc1388.Position;
import org.usfirst.frc1388.Objective;
import org.usfirst.frc1388.Robot;
import org.usfirst.frc1388.RobotMap;
import org.usfirst.frc1388.UsbLogging;
import org.usfirst.frc1388.subsystems.*;
import org.usfirst.frc1388.subsystems.Elevator.ElevatorSetpoint;

/**
 *
 */
public class AutonomousInternal extends CommandGroup {

	private Position position;
	private Objective goal;
	private String gameData;
	private final double k_rightTurnAngle = 90;
	private final double k_leftTurnAngle = -90;
	private final double k_robotFrame = 28;
	private final double k_robotBumber = 6;
	private final double k_robotLength = k_robotFrame + k_robotBumber;
	private final double k_switchWall = 140;
	private final double k_autoLine = 120;
	private final double k_autoDistanceWall = k_switchWall - k_robotLength;
	private final double k_autoDistanceLine = k_autoLine - k_robotLength;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PARAMETERS
	public AutonomousInternal() {

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PARAMETERS
		// Add Commands here:
		// e.g. addSequential(new Command1());
		//      addSequential(new Command2());
		// these will run in order.

		// To run multiple commands at the same time,
		// use addParallel()
		// e.g. addParallel(new Command1());
		//      addSequential(new Command2());
		// Command1 and Command2 will run in parallel.

		// A command group will require all of the subsystems that each member
		// would require.
		// e.g. if Command1 requires chassis, and Command2 requires arm,
		// a CommandGroup containing them would require both the chassis and the
		// arm.
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS

		// END AUTOGENERATEE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS

		gameData = Robot.gameData; // 3-char string from FMS / Driver Station / ex. "LRL"
		position = Robot.fieldPosition; // Enum equal to value set in positionSelector SendableChooser, set in autonInit
		
		Objective priority = Robot.autonObjective; // Enum equal to value set in autonSelector SendableChooser, set in autonInit
		setGoal(priority);

		//AutonShake command(s)? add here if necessary
		String switchSide = gameData.substring(0, 1); // "L" L L 
		String scaleSide = gameData.substring(1, 2); // L "L" L
		
		switch (goal) {
		case SCALE:
			runScale(position, scaleSide);
			break;

		case SWITCH:
			runSwitch(position, switchSide);
			break;
		default:
			runLine();
		}
	}

	public void runSwitch(Position position, String switchSide) {
		UsbLogging.printLog("Auto: runScale:  position=" + position + "  switchSide=" + switchSide);

		if( position.equals(Position.CENTER) ) {
			
			double w = 38;
			double xL = 89;
			double xR = 65;
			double y = k_autoDistanceWall - w;
			double z = -10;
			// switch Dims 12ft 9.5in wide, 4ft 8in deep, 1ft 6 3/4 in tall
			// scale Dims
			
			
			// Drive forward w
			addSequential( new AutonomousDrive(w));
			
			// Turn Same
			if(switchSide == "L") addSequential( new AutonomousTurnTo(k_leftTurnAngle));
			else addSequential( new AutonomousTurnTo(k_rightTurnAngle));
			
			// Drive Forward x
			if(switchSide == "L") addSequential( new AutonomousDrive(xL));
			else addSequential( new AutonomousDrive(xR));
			
			// Turn Opposite
			if(switchSide == "L") addSequential( new AutonomousTurnTo(k_rightTurnAngle));
			else addSequential( new AutonomousTurnTo(k_leftTurnAngle));
			
			// P Elevator to switch
			addParallel( new AutonomousMoveElevator(ElevatorSetpoint.SWITCH));
			
			// P Drive Forward y
			addParallel( new AutonomousDrive(y));
			
			// Drop Box
			addSequential( new AutonomousRunIntake("out"));
			
			// Drive BackWards z
			addSequential( new AutonomousDrive(z));
			
		}//end if
		else { // position == R or L 

			double x = 151; 
			double y = 10.5;
			double z = -20;
			
			// Drive forward x
			addSequential( new AutonomousDrive(x));
			
			// Turn opposite
			if(switchSide == "L") addSequential( new AutonomousTurnTo(k_rightTurnAngle));
			else addSequential( new AutonomousTurnTo(k_leftTurnAngle));
			
			// P Elevator to switch
			addParallel( new AutonomousMoveElevator(ElevatorSetpoint.SWITCH));
			
			// P Drive forward y
			addSequential( new AutonomousDrive(y));
			
			// drop box
			addSequential( new AutonomousRunIntake("out"));
			
			// Drive backwards z
			addSequential( new AutonomousDrive(z));
		}
	}

	public void runScale(Position position, String scaleSide) {
		UsbLogging.printLog("Auto: runScale:  position=" + position + "  scaleSide=" + scaleSide);
		double x = 307; 
		double y = -19;
		double z = -10;
		
		// Drive forward x
		addSequential( new AutonomousDrive(x));
		
		// Turn opposite
		if(scaleSide == "L") addSequential( new AutonomousTurnTo(k_rightTurnAngle));
		else addSequential( new AutonomousTurnTo(k_leftTurnAngle));
		
		// P Elevator to switch
		addParallel( new AutonomousMoveElevator(ElevatorSetpoint.SCALE));
		
		// P Drive backwards y
		addSequential( new AutonomousDrive(y));
		
		addSequential(new WaitCommand(1));
		
		// Drive Forward
		addSequential( new AutonomousDrive(3)); // 3 is to get the arms over the scale edge
		
		// drop box
		addSequential( new AutonomousRunIntake("out"));
		
		// Drive backwards z
		addSequential( new AutonomousDrive(z));
		
		// Lower Elevator
	}

	public void runLine() {
		UsbLogging.printLog("Auto: runLine");
		addSequential( new AutonomousDrive(k_autoDistanceWall));
//		addSequential( new AutonomousDrive(k_autoDistanceLine));
//		addSequential( new AutonomousTurnTo(180));
//		addSequential( new AutonomousDrive(k_autoDistanceLine-k_robotFrame));
//		addSequential( new AutonomousTurnTo(0));
//		addSequential( new AutonomousDrive(k_autoDistanceLine-k_robotFrame));
//		addSequential( new AutonomousTurnTo(-180));
//		addSequential( new AutonomousDrive(k_autoDistanceLine-k_robotFrame));
	}

	/**
	 * 
	 * @param position Position to compare with gameData item
	 * @param gameData gameData substring to compare with Position
	 * 
	 * @return True if position and gameData are on the same side, false if otherwise
	 */
	private boolean compare(Position position, String gameData) {
		if(position.equals(Position.LEFT) && gameData.equals("L")) {
			return true;
		} 
		else if (position.equals(Position.RIGHT) && gameData.equals("R")) {
			return true;
		}
		
		return false;
	}

	private void setGoal( Objective priority) {

		if( this.gameData.length() != 3 || this.position == null || priority == Objective.LINE ) {
			this.goal = Objective.LINE;
			return;
		}
	
		if( this.position == position.CENTER ) {
			this.goal = Objective.SWITCH;
			return;
		}
		
		String switchSide = gameData.substring(0, 1);
		String scaleSide = gameData.substring(1, 2);

		if( priority.equals(Objective.SWITCH) ) {
			
			if( compare(this.position, switchSide) ) {
				this.goal = Objective.SWITCH;
				return;
			}
			else if( compare(this.position, scaleSide) ) {
				this.goal = Objective.SCALE;
				return;
			}
		}
		
		if( priority.equals(Objective.SCALE) ) {

			if( compare(this.position, scaleSide) ) {
				this.goal = Objective.SCALE;
				return;
			}
			else if( compare(this.position, switchSide) ) {
				this.goal = Objective.SWITCH;
				return;
			} 
		}
		
		this.goal = Objective.LINE;
	}
}


