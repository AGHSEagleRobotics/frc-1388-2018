// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1388.subsystems;

import org.usfirst.frc1388.RobotMap;
import org.usfirst.frc1388.UsbLogging;
import org.usfirst.frc1388.commands.*;

import com.mindsensors.CANSD540;

import edu.wpi.first.wpilibj.command.Subsystem;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Elevator extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final DigitalInput bottomElebvatorSwitch = RobotMap.elevatorbottomElebvatorSwitch;
    private final Encoder elevatorEncoder = RobotMap.elevatorelevatorEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	
	//enums
	private enum ElevatorSensorType{
		LIDAR, 
		ENCODER
	}

    private final DigitalInput bottomLimit = RobotMap.elevatorbottomElebvatorSwitch;
    private final CANSD540 elevatorMotor = RobotMap.elevatorMotor;
    
    //limits
    public final double maxHeight = 50; //inches, not tested
    public final double lowestHeight = 10; //inches, not tested
    
    //lidar
    private final double lidarOffset = 3; //inches, distance from base of lidar to floor, not tested
    private final double inPerCm = (1 / 2.54); //inches per centimeter, not sure what the number is...
    
    //elevator motor limits
    private final double maxPwrUp = .5; //max power when moving up, not tested
    private final double finalPwrUp = 0.15; //max power when elevator is at top, not tested
    private final double rampDistUp = 12; //distance from top when power will scale down, not tested
    
    private final double maxPwrDwn = -.2; //max power when moving down, not tested
    private final double finalPwrDwn = -0.1; //max power when elevator is at bottom, not tested
    private final double rampDistDwn = 20; //distance from bottom when power will scale down, not tested

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new MoveElevator());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
    	
    	double currentPwr = RobotMap.elevatorMotor.get();
    	double limitedPwr = limitMotorPwr(currentPwr);
    	RobotMap.elevatorMotor.set(limitedPwr);
    	
    	// Check if the power limit has been violated:
        if (Math.abs(currentPwr - limitedPwr) > 0.1) {
           UsbLogging.printLog("Warning: Elevator motor power limit exceeded!");
        }

        // Zero the encoder if the elevator is at the bottom limit switch
        if (atBottomLimit()) {
           elevatorEncoder.reset();
        }
    	

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    /**
     * Determine if the elevator is at the bottom limit
     * <p>
     * The lower limit is a hard limit, implemented as a limit switch.
     *  
     * @return    Elevator is at the lower limit
     */
    public boolean atBottomLimit() {
       return bottomLimit.get();
    }
    
    /**
     * Determine if the elevator is at the top limit
     * <p>
     * The top limit is a soft limit, determined by elevator height.
     *  
     * @return    Elevator is at the upper limit
     */
    public boolean atTopLimit() {
        boolean atLimit = true;     // default is the safest value
        
        double height = getHeight();
        
        if ((height < maxHeight) && (height >= 0)) {
           atLimit = false;
        }
        return atLimit;
        
    }
     

    /**
     * Return the elevator height
     * <p>
     * If the height cannot be determined, a negative value will be returned
     *  
     * @return    Height in inches, or negative if height cannot be determined
     */
    public double getHeight() {
       // Which sensor to use?
       final ElevatorSensorType heightSensorMethod = ElevatorSensorType.ENCODER;
       
       double height = -1;     // default indicates an error
       
       switch (heightSensorMethod) {
          case LIDAR:
            // get the height from the LIDAR
            //height = getLidarMeasurement();
        	  height = 0;
            
            if ((height < 0) || (height > (maxHeight + 10))) { //why + 10?
               // something is wrong
               height = -1;
            }
            break;
            
          case ENCODER:
            height = elevatorEncoder.getDistance();
            break;
            
          default:
            // unknown sensor type
            height = -1;
            break;
       }
       
       return height;
    }

    
    /**
     * Set the elevator motor power, after enforcing power limits
     * <p>
     * To ensure that the elevator is not overdriven, this method should be used to set the motor power,
     * and the motor's power should NOT be set directly using the motor's set() method.
     *  
     * @param     pwr   Desired motor power
     * @return          Actual motor power that was set
     */
    public double setMotor(double pwr) {
       double limitedPwr = limitMotorPwr(pwr);
              
       elevatorMotor.set(limitedPwr);
       
       return limitedPwr;
    }
       
    
    /**
     * Check elevator motor power limits
     * <p>
     * Desired motor power is limited based on max allowable power, physical limits, and proximity to physical limits.
     *  
     * @param     pwr   Desired motor power
     * @return          Limited motor power
     */
    public double limitMotorPwr(double pwr) {
       double height = getHeight();
       
       // top/bottom limits (limit switches or soft limits)
       if (atTopLimit()    && (pwr > 0)) pwr = 0;                          // Do not go up
       if (atBottomLimit() && (pwr < 0)) pwr = 0;                          // Do not go down
       
       // max power limit
       if (pwr > maxPwrUp) pwr = maxPwrUp;                       // Never exceed the max Up power
       if (pwr < maxPwrDwn) pwr = maxPwrDwn;                       // Never exceed the max Down power
       
       // Reduce the power as the elevator approaches top/bottom limits
       if (height > 0) {
         // Height of the elevator is known; apply ramped limits based on height
         double upLimit, dnLimit, distance, slope;
          
         // limit the power when approaching the top limit
         distance = maxHeight - height;                               // distance from the limit
         slope = (maxPwrUp - finalPwrUp) / rampDistUp;      // slope of the limit = y / x
         upLimit = finalPwrUp + (distance * slope);
         if (pwr > upLimit) pwr = upLimit;

         // limit the power when approaching the bottom limit
         distance = height - lowestHeight;                            // distance from the limit
         slope = (maxPwrDwn - finalPwrDwn) / rampDistDwn;      // slope of the limit = y / x
         dnLimit = finalPwrDwn + (distance * slope);
         if (pwr < dnLimit) pwr = dnLimit;
       }
       else {
         // height is unknown; apply "final" limits
         if (pwr > finalPwrUp) pwr = finalPwrUp;
         if (pwr < finalPwrDwn) pwr = finalPwrDwn;
       }
       
       return pwr;
    }

}

